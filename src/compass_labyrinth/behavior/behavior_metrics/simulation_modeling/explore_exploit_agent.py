'''
    EXPLORATION-EXPLOITATION AGENT MODELING AND ANALYSIS
    Author: Shreya Bangera 
'''
import pandas as pd
import numpy as np
import random
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.formula.api import mixedlm

###############################################################
# Exploration-Exploitation Agent Evaluation 
###############################################################
# ---------------------------
# Transition Tracking Utility
# ---------------------------
def track_valid_and_optimal_transitions_EE(df, decision_label, reward_label):
    valid_transitions, optimal_transitions = {}, {}

    for session, group in df.groupby('Session'):
        session_valid, session_optimal = {}, {}

        for i in range(len(group) - 1):
            if group.iloc[i]['NodeType'] == decision_label:
                current = group.iloc[i]['Grid Number']
                next_grid = group.iloc[i + 1]['Grid Number']
                next_region = group.iloc[i + 1]['Region']

                session_valid.setdefault(current, set()).add(next_grid)
                if next_region == reward_label:
                    session_optimal.setdefault(current, set()).add(next_grid)

        valid_transitions[session] = session_valid
        optimal_transitions[session] = session_optimal

    return valid_transitions, optimal_transitions

# ------------------------------
# Agent Simulation Function
# ------------------------------
def simulate_exploration_agent_EE(segment, valid_dict, optimal_dict, exploration_rate, n_simulations, decision_label):
    actual, simulated = [], []

    for i in range(len(segment) - 1):
        if segment.iloc[i]['NodeType'] == decision_label:
            curr = segment.iloc[i]['Grid Number']
            actual_next = segment.iloc[i + 1]['Grid Number']

            actual.append(1 if actual_next in optimal_dict.get(curr, set()) else 0)
            trials = []
            for _ in range(n_simulations):
                if curr in valid_dict:
                    if random.random() > exploration_rate and curr in optimal_dict:
                        choice = random.choice(list(optimal_dict[curr]))
                    else:
                        choice = random.choice(list(valid_dict[curr]))

                    trials.append(1 if choice in optimal_dict.get(curr, set()) else 0)
            simulated.append(np.mean(trials))

    return actual, simulated

# ------------------------------
# Metric Calculation Function
# ------------------------------
def calculate_segment_metrics_EE(segment, valid_dict, optimal_dict, exploration_rate, n_bootstrap, n_simulations, decision_label):
    if segment.empty or decision_label not in segment['NodeType'].values:
        return pd.Series({k: np.nan for k in [
            'Actual Reward Path %', 'Agent Reward Path %',
            'Actual Reward Path % CI Lower', 'Actual Reward Path % CI Upper',
            'Agent Reward Path % CI Lower', 'Agent Reward Path % CI Upper',
            'Relative Performance']})

    actual, simulated = simulate_exploration_agent_EE(segment, valid_dict, optimal_dict, exploration_rate, n_simulations, decision_label)
    if not actual or not simulated:
        return pd.Series({k: np.nan for k in [
            'Actual Reward Path %', 'Agent Reward Path %',
            'Actual Reward Path % CI Lower', 'Actual Reward Path % CI Upper',
            'Agent Reward Path % CI Lower', 'Agent Reward Path % CI Upper',
            'Relative Performance']})

    def bootstrap(data):
        return np.random.choice(data, (n_bootstrap, len(data)), replace=True)

    actual_means = np.mean(bootstrap(actual), axis=1)
    agent_means = np.mean(bootstrap(simulated), axis=1)

    return pd.Series({
        'Actual Reward Path %': np.mean(actual_means),
        'Agent Reward Path %': np.mean(agent_means),
        'Actual Reward Path % CI Lower': np.percentile(actual_means, 5),
        'Actual Reward Path % CI Upper': np.percentile(actual_means, 95),
        'Agent Reward Path % CI Lower': np.percentile(agent_means, 5),
        'Agent Reward Path % CI Upper': np.percentile(agent_means, 95),
        'Relative Performance': np.mean(actual_means) / np.mean(agent_means) if np.mean(agent_means) > 0 else np.nan
    })

# ------------------------------
# Data Split Utility
# ------------------------------
def split_sessions_into_segments_EE(df, segment_size):
    segments = []
    for _, group in df.groupby(['Genotype', 'Session']):
        n_parts = len(group) // segment_size + 1
        for i in range(n_parts):
            part = group.iloc[i * segment_size: (i + 1) * segment_size]
            if not part.empty:
                segments.append((group['Session'].iloc[0], i + 1, part))
    return segments

# ------------------------------
# Analysis Runner
# ------------------------------
def run_exploration_agent_analysis_EE(df, exploration_rate, segment_size=1000, n_bootstrap=10000, n_simulations=100, decision_label='Decision (Reward)', reward_label='Reward Path'):
    valid_dict, optimal_dict = track_valid_and_optimal_transitions_EE(df, decision_label, reward_label)
    segments = split_sessions_into_segments_EE(df, segment_size)
    results = []

    for session, seg_num, segment in segments:
        metrics = calculate_segment_metrics_EE(segment, valid_dict.get(session, {}), optimal_dict.get(session, {}),
                                            exploration_rate, n_bootstrap, n_simulations, decision_label)
        metrics['Session'] = session
        metrics['Epoch Number'] = seg_num
        results.append(metrics)

    return pd.DataFrame(results)

###############################################################
## Plot 7: Agent Performance Across Varying Exploration Rates
###############################################################

def trim_to_common_epochs(df_results):
    """
    Trims the results dataframe to retain only the maximum number of epochs common across all sessions.

    Parameters:
    - df_results (pd.DataFrame): The output of evaluate_agent_performance.
    - 'Session' (str): Column name indicating sessions.
    - 'Epoch_Number' (str): Column name indicating epoch/bin number.

    Returns:
    - pd.DataFrame: Trimmed dataframe with only common epochs.
    """
    df_trimmed = df_results.copy()

    # Ensure correct dtypes
    df_trimmed['Session'] = df_trimmed['Session'].astype(int)
    df_trimmed['Epoch Number'] = df_trimmed['Epoch Number'].astype(int)

    # Find common epochs across all sessions
    epoch_sets = df_trimmed.groupby('Session')['Epoch Number'].apply(set)
    common_epochs = set.intersection(*epoch_sets)
    
    if not common_epochs:
        print("Warning: No common epochs across sessions. Returning original dataframe.")
        return df_trimmed

    max_common_epoch = max(common_epochs)
    print(f" Max common epoch across all sessions: {max_common_epoch}")

    # Filter
    df_trimmed = df_trimmed[df_trimmed['Epoch Number'] <= max_common_epoch].reset_index(drop=True)
    return df_trimmed

def plot_exploration_rate_performance_EE(df_source, exploration_rates, segment_size=1000, trim_dataframe=True, decision_label='Decision (Reward)', reward_label='Reward Path'):
    plt.figure(figsize=(15, 8))

    for er in exploration_rates:
        er_rounded = round(er, 1)
        print('Exploration rate = ',er_rounded,' being processed....')
        result_df = run_exploration_agent_analysis_EE(df_source, exploration_rate=er_rounded, segment_size=segment_size,
                                                   decision_label=decision_label, reward_label=reward_label)
        # Best to use trimmed dataframe after cutting to max. common epoch number scross Sessions
        if trim_dataframe:
            result_df = trim_to_common_epochs(result_df)
        sns.lineplot(data=result_df, x="Epoch Number", y="Agent Reward Path %", linestyle="--", label=f"Agent (ER={er_rounded})")

    # Plot actual performance
    last_df = run_exploration_agent_analysis_EE(df_source, exploration_rate=exploration_rates[-1], segment_size=segment_size,
                                             decision_label=decision_label, reward_label=reward_label)
    if trim_dataframe:
        last_df = trim_to_common_epochs(last_df)
    sns.lineplot(data=last_df, x="Epoch Number", y="Actual Reward Path %", marker="o", label="Mouse", color='black')

    plt.xlabel("Epochs (in maze)")
    plt.ylabel("Proportion of Reward Path Transitions")
    plt.title("Mouse vs. Exploration Agent Reward Path Transition Proportion")
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.grid(True)
    plt.tight_layout()
    #plt.show()
